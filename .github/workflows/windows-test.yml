name: Windows Tests

on:
  push:
    branches: [ main ]
    paths:
      - 'fuwarp_windows.py'
      - '.github/workflows/windows-test.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'fuwarp_windows.py'
      - '.github/workflows/windows-test.yml'
  workflow_dispatch:  # Allow manual triggering if needed

jobs:
  test-windows:
    runs-on: windows-latest

    steps:
    - uses: actions/checkout@v3

    # Just use whatever Python comes with windows-latest
    # No need to test multiple versions for basic file operations

    - name: Create mock warp-cli
      shell: pwsh
      run: |
        # Create a mock warp-cli.bat that returns a test certificate
        @'
        @echo off
        if "%1"=="certs" (
          echo -----BEGIN CERTIFICATE-----
          echo MIIDQTCCAimgAwIBAgITBmyfz5m/jAo54vB4ikPmljZbyjANBgkqhkiG9w0BAQsF
          echo ADAkMSIwIAYDVQQDDBlDbG91ZGZsYXJlIEZvciBUZWFtcyBFQ0MwHhcNMjAwODAz
          echo -----END CERTIFICATE-----
        )
        if "%1"=="status" (
          echo Status: Connected
        )
        '@ | Out-File -FilePath warp-cli.bat -Encoding ASCII

        # Add current directory to PATH so our mock is found
        echo "$PWD" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

    - name: Test script imports and basic functionality
      shell: pwsh
      run: |
        # Set UTF-8 encoding for Python to handle Unicode characters
        $env:PYTHONIOENCODING = "utf-8"

        # Test direct script execution (not as a module import)
        python fuwarp_windows.py --help
        python fuwarp_windows.py --list-tools

    - name: Test in status mode (read-only)
      shell: pwsh
      run: |
        # Set UTF-8 encoding for Python to handle Unicode characters
        $env:PYTHONIOENCODING = "utf-8"
        python fuwarp_windows.py

    - name: Test path construction
      shell: pwsh
      run: |
        # Set UTF-8 encoding for Python
        $env:PYTHONIOENCODING = "utf-8"

        python -c @"
        import os
        import sys
        # Import the module by executing the file directly to get the class
        exec(open('fuwarp_windows.py').read(), globals())  # This loads FuwarpWindows class

        # Test that paths are properly constructed for Windows
        fw = FuwarpWindows(mode='status', debug=True)

        # Test get_tool_bundle_path
        path = fw.get_tool_bundle_path('test')
        print(f'Bundle path: {path}')

        # Check no mixed separators (shouldn't have forward slashes after drive letter)
        if ':' in path:  # Windows path with drive letter
            path_after_drive = path[2:]  # Skip 'C:' part
            assert '/' not in path_after_drive, f'Mixed separators found: {path}'

        # Test that CLOUDFLARE_WARP_DIR uses proper separators
        # CLOUDFLARE_WARP_DIR is a global variable that was loaded
        warp_dir = CLOUDFLARE_WARP_DIR
        print(f'WARP dir: {warp_dir}')

        if ':' in warp_dir:
            warp_after_drive = warp_dir[2:]
            assert '/' not in warp_after_drive, f'Mixed separators in CLOUDFLARE_WARP_DIR: {warp_dir}'

        print('Path construction tests passed')
        "@

    - name: Test certificate download with mock
      shell: pwsh
      run: |
        # Set UTF-8 encoding for Python
        $env:PYTHONIOENCODING = "utf-8"

        python -c @"
        import sys
        # Import the module by executing the file directly
        exec(open('fuwarp_windows.py').read(), globals())

        fw = FuwarpWindows(mode='status', debug=True)
        result = fw.download_certificate()
        assert result == True, 'Certificate download should succeed with mock'
        print('Certificate download test passed')
        "@

    - name: Test specific bug fix - same file copy protection
      shell: pwsh
      run: |
        # Set UTF-8 encoding for Python
        $env:PYTHONIOENCODING = "utf-8"

        # Test that we don't try to copy a file to itself
        python -c @"
        import os
        import sys
        import tempfile
        # Import the module by executing the file directly
        exec(open('fuwarp_windows.py').read(), globals())

        fw = FuwarpWindows(mode='status', debug=True)

        # Create a temp file to test with
        with tempfile.NamedTemporaryFile(mode='w', suffix='.pem', delete=False) as tf:
            tf.write('test content')
            temp_path = tf.name

        try:
            # Test that append_certificate_if_missing handles same file gracefully
            result = fw.append_certificate_if_missing(temp_path, temp_path)
            assert result == True, 'Should handle same file gracefully'
            print('Same-file protection test passed')
        finally:
            os.unlink(temp_path)
        "@

    - name: Test newline handling - file without trailing newline (issue #13)
      shell: pwsh
      run: |
        $env:PYTHONIOENCODING = "utf-8"

        python -c @"
        import os
        import re
        import tempfile
        exec(open('fuwarp_windows.py').read(), globals())

        fw = FuwarpWindows(mode='install', debug=True)

        # Create certificate content (with trailing newline)
        cert_content = '-----BEGIN CERTIFICATE-----\nMIIEjTCCA3WgAwIBAgISA2Q1\n-----END CERTIFICATE-----\n'

        # Create bundle WITHOUT trailing newline (the bug scenario from issue #13)
        bundle_no_newline = '-----BEGIN CERTIFICATE-----\nMIIDSjCCAjKgAwIBAgIQRK\n-----END CERTIFICATE-----'

        with tempfile.TemporaryDirectory() as tmpdir:
            bundle_path = os.path.join(tmpdir, 'bundle.pem')
            cert_path = os.path.join(tmpdir, 'cert.pem')

            # Write bundle WITHOUT trailing newline using binary mode
            with open(bundle_path, 'wb') as f:
                f.write(bundle_no_newline.encode('utf-8'))

            with open(cert_path, 'w') as f:
                f.write(cert_content)

            # Verify bundle doesn't end with newline
            with open(bundle_path, 'rb') as f:
                f.seek(-1, 2)
                last_byte = f.read(1)
                assert last_byte == b'-', f'Setup error: bundle should end with dash, got {last_byte!r}'

            # Call append - this is what we're testing
            result = fw.append_certificate_if_missing(cert_path, bundle_path)
            assert result == True, 'Append should succeed'

            # Read result and verify proper PEM formatting
            with open(bundle_path, 'r') as f:
                content = f.read()

            # THE CRITICAL CHECK: malformed PEM pattern must NOT exist
            malformed = '-----END CERTIFICATE----------BEGIN CERTIFICATE-----'
            assert malformed not in content, f'MALFORMED PEM DETECTED!'

            # Verify proper separation exists (newline between certs)
            proper = re.search(r'-----END CERTIFICATE-----\r?\n+-----BEGIN CERTIFICATE-----', content)
            assert proper, 'Expected newline separation between certificates'

            print('Test PASSED: File without trailing newline handled correctly')
        "@

    - name: Test newline handling - file with CRLF ending
      shell: pwsh
      run: |
        $env:PYTHONIOENCODING = "utf-8"

        python -c @"
        import os
        import re
        import tempfile
        exec(open('fuwarp_windows.py').read(), globals())

        fw = FuwarpWindows(mode='install', debug=True)

        cert_content = '-----BEGIN CERTIFICATE-----\nMIIEjTCCA3WgAwIBAgISA2Q1\n-----END CERTIFICATE-----\n'

        # Bundle with explicit CRLF line endings
        bundle_crlf = '-----BEGIN CERTIFICATE-----\r\nMIIDSjCCAjKgAwIBAgIQRK\r\n-----END CERTIFICATE-----\r\n'

        with tempfile.TemporaryDirectory() as tmpdir:
            bundle_path = os.path.join(tmpdir, 'bundle.pem')
            cert_path = os.path.join(tmpdir, 'cert.pem')

            with open(bundle_path, 'wb') as f:
                f.write(bundle_crlf.encode('utf-8'))

            with open(cert_path, 'w') as f:
                f.write(cert_content)

            # Verify bundle ends with LF (the \n part of CRLF)
            with open(bundle_path, 'rb') as f:
                f.seek(-1, 2)
                last_byte = f.read(1)
                assert last_byte == b'\n', f'Setup error: expected LF, got {last_byte!r}'

            result = fw.append_certificate_if_missing(cert_path, bundle_path)
            assert result == True

            with open(bundle_path, 'r') as f:
                content = f.read()

            # Should NOT have malformed PEM
            assert '-----END CERTIFICATE----------BEGIN CERTIFICATE-----' not in content

            # Should NOT have excessive blank lines (3+ newlines between certs)
            excessive = re.search(r'-----END CERTIFICATE-----(\r?\n){3,}-----BEGIN CERTIFICATE-----', content)
            assert not excessive, 'Too many blank lines between certificates'

            print('Test PASSED: File with CRLF ending handled correctly')
        "@

    - name: Test newline handling - file with LF-only ending (Unix style)
      shell: pwsh
      run: |
        $env:PYTHONIOENCODING = "utf-8"

        python -c @"
        import os
        import tempfile
        exec(open('fuwarp_windows.py').read(), globals())

        fw = FuwarpWindows(mode='install', debug=True)

        cert_content = '-----BEGIN CERTIFICATE-----\nMIIEjTCCA3WgAwIBAgISA2Q1\n-----END CERTIFICATE-----\n'

        # Bundle with Unix-style LF only (common when files come from git)
        bundle_lf = '-----BEGIN CERTIFICATE-----\nMIIDSjCCAjKgAwIBAgIQRK\n-----END CERTIFICATE-----\n'

        with tempfile.TemporaryDirectory() as tmpdir:
            bundle_path = os.path.join(tmpdir, 'bundle.pem')
            cert_path = os.path.join(tmpdir, 'cert.pem')

            with open(bundle_path, 'wb') as f:
                f.write(bundle_lf.encode('utf-8'))

            with open(cert_path, 'w') as f:
                f.write(cert_content)

            result = fw.append_certificate_if_missing(cert_path, bundle_path)
            assert result == True

            with open(bundle_path, 'r') as f:
                content = f.read()

            assert '-----END CERTIFICATE----------BEGIN CERTIFICATE-----' not in content
            print('Test PASSED: File with LF-only ending handled correctly')
        "@