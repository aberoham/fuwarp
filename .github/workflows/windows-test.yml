name: Windows Tests

on:
  push:
    branches: [ main ]
    paths:
      - 'fuwarp-windows.py'
      - '.github/workflows/windows-test.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'fuwarp-windows.py'
      - '.github/workflows/windows-test.yml'
  workflow_dispatch:  # Allow manual triggering if needed

jobs:
  test-windows:
    runs-on: windows-latest

    steps:
    - uses: actions/checkout@v3

    # Just use whatever Python comes with windows-latest
    # No need to test multiple versions for basic file operations

    - name: Create mock warp-cli
      shell: pwsh
      run: |
        # Create a mock warp-cli.bat that returns a test certificate
        @'
        @echo off
        if "%1"=="certs" (
          echo -----BEGIN CERTIFICATE-----
          echo MIIDQTCCAimgAwIBAgITBmyfz5m/jAo54vB4ikPmljZbyjANBgkqhkiG9w0BAQsF
          echo ADAkMSIwIAYDVQQDDBlDbG91ZGZsYXJlIEZvciBUZWFtcyBFQ0MwHhcNMjAwODAz
          echo -----END CERTIFICATE-----
        )
        if "%1"=="status" (
          echo Status: Connected
        )
        '@ | Out-File -FilePath warp-cli.bat -Encoding ASCII

        # Add current directory to PATH so our mock is found
        echo "$PWD" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

    - name: Test script imports and basic functionality
      shell: pwsh
      run: |
        # Set UTF-8 encoding for Python to handle Unicode characters
        $env:PYTHONIOENCODING = "utf-8"

        # Test direct script execution (not as a module import)
        python fuwarp-windows.py --help
        python fuwarp-windows.py --version

    - name: Test in status mode (read-only)
      shell: pwsh
      run: |
        # Set UTF-8 encoding for Python to handle Unicode characters
        $env:PYTHONIOENCODING = "utf-8"
        python fuwarp-windows.py

    - name: Test path construction
      shell: pwsh
      run: |
        # Set UTF-8 encoding for Python
        $env:PYTHONIOENCODING = "utf-8"

        python -c @"
        import os
        import sys
        # Import the module by executing the file directly to get the class
        exec(open('fuwarp-windows.py').read(), globals())  # This loads FuwarpWindows class

        # Test that paths are properly constructed for Windows
        fw = FuwarpWindows(mode='status', debug=True)

        # Test get_tool_bundle_path
        path = fw.get_tool_bundle_path('test')
        print(f'Bundle path: {path}')

        # Check no mixed separators (shouldn't have forward slashes after drive letter)
        if ':' in path:  # Windows path with drive letter
            path_after_drive = path[2:]  # Skip 'C:' part
            assert '/' not in path_after_drive, f'Mixed separators found: {path}'

        # Test that CLOUDFLARE_WARP_DIR uses proper separators
        # CLOUDFLARE_WARP_DIR is a global variable that was loaded
        warp_dir = CLOUDFLARE_WARP_DIR
        print(f'WARP dir: {warp_dir}')

        if ':' in warp_dir:
            warp_after_drive = warp_dir[2:]
            assert '/' not in warp_after_drive, f'Mixed separators in CLOUDFLARE_WARP_DIR: {warp_dir}'

        print('Path construction tests passed')
        "@

    - name: Test certificate download with mock
      shell: pwsh
      run: |
        # Set UTF-8 encoding for Python
        $env:PYTHONIOENCODING = "utf-8"

        python -c @"
        import sys
        # Import the module by executing the file directly
        exec(open('fuwarp-windows.py').read(), globals())

        fw = FuwarpWindows(mode='status', debug=True)
        result = fw.download_certificate()
        assert result == True, 'Certificate download should succeed with mock'
        print('Certificate download test passed')
        "@

    - name: Test specific bug fix - same file copy protection
      shell: pwsh
      run: |
        # Set UTF-8 encoding for Python
        $env:PYTHONIOENCODING = "utf-8"

        # Test that we don't try to copy a file to itself
        python -c @"
        import os
        import sys
        import tempfile
        # Import the module by executing the file directly
        exec(open('fuwarp-windows.py').read(), globals())

        fw = FuwarpWindows(mode='status', debug=True)

        # Create a temp file to test with
        with tempfile.NamedTemporaryFile(mode='w', suffix='.pem', delete=False) as tf:
            tf.write('test content')
            temp_path = tf.name

        try:
            # Test that append_certificate_if_missing handles same file gracefully
            result = fw.append_certificate_if_missing(temp_path, temp_path)
            assert result == True, 'Should handle same file gracefully'
            print('Same-file protection test passed')
        finally:
            os.unlink(temp_path)
        "@

    - name: Test newline handling - file without trailing newline (issue #13)
      shell: pwsh
      run: |
        $env:PYTHONIOENCODING = "utf-8"

        python -c @"
        import os
        import tempfile
        exec(open('fuwarp-windows.py').read(), globals())

        fw = FuwarpWindows(mode='install', debug=True)

        # Create a mock certificate to append
        cert_content = '''-----BEGIN CERTIFICATE-----
MIIEjTCCA3WgAwIBAgISA2Q1Q5XQHgYE8xhA9PkyCgypMA0GCSqGSIb3DQEBCwUA
MDIxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1MZXQncyBFbmNyeXB0MQswCQYDVQQD
-----END CERTIFICATE-----
'''

        # Create a bundle file WITHOUT trailing newline (the bug scenario)
        bundle_no_newline = '''-----BEGIN CERTIFICATE-----
MIIDSjCCAjKgAwIBAgIQRK+wgNajJ7qJMDmGLvhAazANBgkqhkiG9w0BAQUFADA/
MSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMT
-----END CERTIFICATE-----'''  # Note: NO newline at end

        with tempfile.TemporaryDirectory() as tmpdir:
            bundle_path = os.path.join(tmpdir, 'bundle.pem')
            cert_path = os.path.join(tmpdir, 'cert.pem')

            # Write bundle WITHOUT trailing newline using binary mode to be explicit
            with open(bundle_path, 'wb') as f:
                f.write(bundle_no_newline.encode('utf-8'))

            # Write cert file
            with open(cert_path, 'w') as f:
                f.write(cert_content)

            # Verify bundle doesn't end with newline
            with open(bundle_path, 'rb') as f:
                f.seek(-1, 2)
                last_byte = f.read(1)
                assert last_byte == b'-', f'Expected bundle to end with dash, got {last_byte!r}'

            # Call append
            result = fw.append_certificate_if_missing(cert_path, bundle_path)
            assert result == True, 'Append should succeed'

            # Read result and verify proper PEM formatting
            with open(bundle_path, 'r') as f:
                content = f.read()

            # THE CRITICAL CHECK: malformed PEM pattern must NOT exist
            malformed_pattern = '-----END CERTIFICATE----------BEGIN CERTIFICATE-----'
            assert malformed_pattern not in content, f'MALFORMED PEM DETECTED! Content contains: {malformed_pattern}'

            # Verify proper separation exists (newline between certs)
            # On Windows, this could be \r\n or \n depending on how file was written
            import re
            proper_separation = re.search(r'-----END CERTIFICATE-----\r?\n+-----BEGIN CERTIFICATE-----', content)
            assert proper_separation, f'Expected proper newline separation between certificates. Content:\\n{content}'

            print('Test PASSED: File without trailing newline handled correctly')
        "@

    - name: Test newline handling - file with CRLF ending
      shell: pwsh
      run: |
        $env:PYTHONIOENCODING = "utf-8"

        python -c @"
        import os
        import tempfile
        exec(open('fuwarp-windows.py').read(), globals())

        fw = FuwarpWindows(mode='install', debug=True)

        cert_content = '''-----BEGIN CERTIFICATE-----
MIIEjTCCA3WgAwIBAgISA2Q1Q5XQHgYE8xhA9PkyCgypMA0GCSqGSIb3DQEBCwUA
-----END CERTIFICATE-----
'''

        # Create bundle with explicit CRLF ending
        bundle_crlf = '-----BEGIN CERTIFICATE-----\r\nMIIDSjCCAjKgAwIBAgIQRK\r\n-----END CERTIFICATE-----\r\n'

        with tempfile.TemporaryDirectory() as tmpdir:
            bundle_path = os.path.join(tmpdir, 'bundle.pem')
            cert_path = os.path.join(tmpdir, 'cert.pem')

            # Write bundle with CRLF using binary mode
            with open(bundle_path, 'wb') as f:
                f.write(bundle_crlf.encode('utf-8'))

            with open(cert_path, 'w') as f:
                f.write(cert_content)

            # Verify bundle ends with LF (the \n part of CRLF)
            with open(bundle_path, 'rb') as f:
                f.seek(-1, 2)
                last_byte = f.read(1)
                assert last_byte == b'\n', f'Expected CRLF ending (last byte LF), got {last_byte!r}'

            result = fw.append_certificate_if_missing(cert_path, bundle_path)
            assert result == True

            with open(bundle_path, 'r') as f:
                content = f.read()

            # Should NOT have malformed PEM
            assert '-----END CERTIFICATE----------BEGIN CERTIFICATE-----' not in content

            # Should NOT have excessive blank lines (more than 2 newlines between certs)
            import re
            excessive_newlines = re.search(r'-----END CERTIFICATE-----(\r?\n){3,}-----BEGIN CERTIFICATE-----', content)
            assert not excessive_newlines, f'Too many blank lines between certificates'

            print('Test PASSED: File with CRLF ending handled correctly')
        "@

    - name: Test newline handling - file with LF-only ending (Unix style on Windows)
      shell: pwsh
      run: |
        $env:PYTHONIOENCODING = "utf-8"

        python -c @"
        import os
        import tempfile
        exec(open('fuwarp-windows.py').read(), globals())

        fw = FuwarpWindows(mode='install', debug=True)

        cert_content = '''-----BEGIN CERTIFICATE-----
MIIEjTCCA3WgAwIBAgISA2Q1Q5XQHgYE8xhA9PkyCgypMA0GCSqGSIb3DQEBCwUA
-----END CERTIFICATE-----
'''

        # Create bundle with Unix-style LF only (common when files come from git)
        bundle_lf = '-----BEGIN CERTIFICATE-----\nMIIDSjCCAjKgAwIBAgIQRK\n-----END CERTIFICATE-----\n'

        with tempfile.TemporaryDirectory() as tmpdir:
            bundle_path = os.path.join(tmpdir, 'bundle.pem')
            cert_path = os.path.join(tmpdir, 'cert.pem')

            # Write bundle with LF only using binary mode
            with open(bundle_path, 'wb') as f:
                f.write(bundle_lf.encode('utf-8'))

            with open(cert_path, 'w') as f:
                f.write(cert_content)

            result = fw.append_certificate_if_missing(cert_path, bundle_path)
            assert result == True

            with open(bundle_path, 'r') as f:
                content = f.read()

            assert '-----END CERTIFICATE----------BEGIN CERTIFICATE-----' not in content
            print('Test PASSED: File with LF-only ending handled correctly')
        "@